#core/query_utils.py
import re
import json
import time
from google.api_core.exceptions import GoogleAPIError
from core.config import log, bigquery_client, genai_client, GEMINI_MODEL, BQ_DATASET, BQ_TABLE

# ------------------------------------------------------------
# Helper: Clean and validate SQL
# ------------------------------------------------------------
def sanitize_sql(query: str) -> str:
    """
    Cleans the SQL generated by Gemini to ensure only safe SELECT queries run.
    """
    query = query.strip().rstrip(";")

    if not query.lower().startswith("select"):
        raise ValueError("Only SELECT queries are allowed.")
    if re.search(r"\b(delete|update|insert|drop|alter)\b", query, re.IGNORECASE):
        raise ValueError("Unsafe SQL command detected.")
    
    return query

# ------------------------------------------------------------
# Helper: Run SQL on BigQuery
# ------------------------------------------------------------
async def execute_bigquery(sql: str):
    """Executes SQL query safely on BigQuery and returns results."""
    try:
        query_job = bigquery_client.query(sql)
        results = [dict(row) for row in query_job.result()]
        log.info(f"üìä Query executed successfully: {len(results)} rows retrieved.")
        return results
    except GoogleAPIError as e:
        log.error(f"‚ùå BigQuery query failed: {e}")
        return [{"error": str(e)}]

# ------------------------------------------------------------
# Core Function: Interpret natural query ‚Üí SQL ‚Üí Answer
# ------------------------------------------------------------
async def run_chatbot_query(user_query: str) -> str:
    """
    Uses Gemini to interpret the user's natural-language query about call records,
    generates SQL, runs it on BigQuery, and returns a short natural-language summary.
    """
    import re, json, time
    start = time.perf_counter()

    # --- 1Ô∏è‚É£ System prompt ---
    system_prompt = f"""
    You are an expert data analyst specializing in telecom customer support analytics.

    You answer user questions by generating the correct BigQuery SQL SELECT query for the following table:
    FROM `{BQ_DATASET}.{BQ_TABLE}`

    Table columns:
    - customer_id (STRING)
    - phone_number (STRING)
    - complaint_type (STRING): possible values are "Network Issue", "Recharge Issue", "Payment Issue", "Others"
    - customer_sentiment (STRING): possible values are "Positive", "Negative", "Neutral"
    - resolved (BOOLEAN): true means resolved, false means unresolved
    - transcript (STRING): entire text of the call

    Your SQL MUST obey these strict rules:
    - Only SELECT statements (never use INSERT, UPDATE, DELETE, CREATE, DROP, etc.).
    - Always use FROM `{BQ_DATASET}.{BQ_TABLE}`.
    - Return no more than 20 rows unless the query is a summary or aggregate.
    - Prefer output columns: phone_number, complaint_type, customer_sentiment, resolved; include other columns only if requested.
    - For summarizing or counting, use COUNT(), GROUP BY, or aggregation as appropriate.
    - Always add a LIMIT 20 to non-aggregate queries for safety.
    - If a query requests data "for today" or "this week", add filtering by timestamp if available or mention that no date filter is possible.
    - Never expose private data or generate queries that could compromise user privacy.

    Good SQL examples:
    Q: How many complaints are unresolved?
    A: SELECT COUNT(*) AS unresolved_count FROM `{BQ_DATASET}.{BQ_TABLE}` WHERE resolved = FALSE;

    Q: List phone numbers and sentiment for network issues.
    A: SELECT phone_number, customer_sentiment, resolved FROM `{BQ_DATASET}.{BQ_TABLE}` WHERE complaint_type = "Network Issue" LIMIT 20;

    Q: Show the three most common complaint types.
    A: SELECT complaint_type, COUNT(*) AS count FROM `{BQ_DATASET}.{BQ_TABLE}` GROUP BY complaint_type ORDER BY count DESC LIMIT 3;

    When ready, generate the SQL (and only the SQL, no explanation) for:
    "{user_query}"
    """

    try:
        # --- 2Ô∏è‚É£ Get SQL from Gemini ---
        response = genai_client.models.generate_content(
            model=GEMINI_MODEL,
            contents=[{"text": system_prompt}],
        )
        sql_text = response.text.strip()
        log.info(f"üß† Gemini generated raw SQL text: {sql_text}")

        # --- 3Ô∏è‚É£ Clean Gemini output ---
        sql_text = re.sub(r"^```sql|```$", "", sql_text, flags=re.IGNORECASE | re.MULTILINE)
        sql_text = sql_text.replace("```", "").replace("‚Äò", "'").replace("‚Äô", "'") \
                           .replace("‚Äú", '"').replace("‚Äù", '"').strip()

        sql_match = re.search(r"SELECT[\s\S]*", sql_text, re.IGNORECASE)
        if not sql_match:
            raise ValueError(f"Gemini did not return valid SQL.\nGot: {sql_text}")
        sql_query = sanitize_sql(sql_match.group(0))

        # --- 4Ô∏è‚É£ Patch missing FROM clause if Gemini forgets ---
        if " from " not in sql_query.lower():
            log.warning("‚ö†Ô∏è Gemini SQL missing FROM clause ‚Äî patching automatically.")
            select_end = sql_query.lower().find("where")
            if select_end != -1:
                sql_query = (
                    sql_query[:select_end].rstrip()
                    + f" FROM `{BQ_DATASET}.{BQ_TABLE}` "
                    + sql_query[select_end:]
                )
            else:
                sql_query += f" FROM `{BQ_DATASET}.{BQ_TABLE}`"

        # --- 5Ô∏è‚É£ Remove transcript column to avoid massive responses ---
        if "transcript" in sql_query.lower() and "count" not in sql_query.lower():
            sql_query = re.sub(r",?\s*transcript\s*", "", sql_query, flags=re.IGNORECASE)
            log.info("üßπ Removed transcript field from SQL to shorten output.")

        log.info(f"üß© Cleaned SQL query: {sql_query}")

        sql_query = re.sub(
            r"FROM\s+`?[\w\-]+\.[\w\-]+`?\s+FROM\s+`?[\w\-]+\.[\w\-]+`?",
            f"FROM `{BQ_DATASET}.{BQ_TABLE}`",
            sql_query,
            flags=re.IGNORECASE
        )

        print("\n----- GEMINI SQL DEBUG -----")
        print(sql_query)
        print("-----------------------------\n")

        # --- 6Ô∏è‚É£ Execute on BigQuery ---
        results = await execute_bigquery(sql_query)
        duration = round(time.perf_counter() - start, 2)

        if not results:
            formatted = "No matching records found."
        elif "error" in results[0]:
            formatted = f"‚ö†Ô∏è Query failed: {results[0]['error']}"
        elif len(results) == 1 and len(results[0]) == 1:
            k, v = list(results[0].items())[0]
            formatted = f"{k.replace('_', ' ').title()}: {v}"
        else:
            sample = results[:3]
            formatted = f"I found {len(results)} matching records. Here are 3 samples:\n{json.dumps(sample, indent=2)}"
            if len(formatted) > 1800:
                formatted = formatted[:1800] + "\n...(truncated)..."

        # --- 7Ô∏è‚É£ Summarize naturally with Gemini ---
        summary_prompt = f"""
        You are an assistant summarizing database query results for a telecom company.
        The user's question was: "{user_query}"
        Here are the raw query results:

        {formatted}

        Write a short, human-readable answer (1-3 sentences),
        directly addressing the user's question.
        Avoid repeating raw JSON or numbers unless relevant.
        """
        try:
            summary_resp = genai_client.models.generate_content(
                model=GEMINI_MODEL,
                contents=[{"text": summary_prompt}],
            )
            final_answer = summary_resp.text.strip()
            log.info("üó£Ô∏è Gemini summary generated successfully.")
        except Exception as e:
            log.warning(f"‚ö†Ô∏è Summary generation failed: {e}")
            final_answer = formatted

        log.info(f"‚úÖ Chatbot query processed in {duration}s")
        return f"{final_answer}\n\nüß© SQL used:\n{sql_query}"

    except Exception as e:
        log.error(f"‚ùå Chatbot query failed: {e}")
        return "Sorry, I couldn‚Äôt understand or process that query."
